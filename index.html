<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flappy â€” Mobile Compatible</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: linear-gradient(#70c5ce, #4ec0ca);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: Arial;
    touch-action: none; /* prevent scroll on mobile */
    -webkit-tap-highlight-color: transparent;
  }
  #wrap {
    position: relative;
  }
  canvas {
    display: block;
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,.25);
  }
  #msg {
    position: absolute;
    width: 100%;
    text-align: center;
    top: 46%;
    transform: translateY(-50%);
    color: #fff;
    font-size: 22px;
    text-shadow: 0 2px 6px rgba(0,0,0,.5);
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="msg">Tap / Click / Space to start</div>
  <canvas id="game"></canvas>
</div>

<script>
(() => {
  // -------- WebAudio + element audio setup --------
  let audioCtx = null;
  function ensureAudioContext() {
    if (!audioCtx) {
      const C = window.AudioContext || window.webkitAudioContext;
      if (C) {
        audioCtx = new C();
        audioCtx.resume().catch(() => {});
      }
    }
  }

  const bgm = new Audio('bgm.mp3');
  bgm.loop = true;
  bgm.volume = 0.35;
  bgm.playsInline = true; // for iOS

  let jumpBuffer = null, gameoverBuffer = null;

  async function loadAudioBuffer(url) {
    try {
      const res = await fetch(url, {cache: 'no-store'});
      const arrayBuffer = await res.arrayBuffer();
      ensureAudioContext();
      if (!audioCtx) return null;
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      return audioBuffer;
    } catch { return null; }
  }

  loadAudioBuffer('jump.mp3').then(b => jumpBuffer = b);
  loadAudioBuffer('gameover.mp3').then(b => gameoverBuffer = b);

  function playBuffer(buffer, volume=1) {
    if (!audioCtx || !buffer) return false;
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.value = volume;
    src.connect(gain).connect(audioCtx.destination);
    src.start(0);
    return true;
  }

  function playAudioFallback(url) {
    const a = new Audio(url);
    a.volume = 1;
    a.currentTime = 0;
    a.play().catch(()=>{});
  }

  // -------- DOM & Game --------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('msg');

  const imgWidth = 810, imgHeight = 1080;
  const imgBBox = { left: 76, right: 88, top: 422, bottom: 39 };

  const userImg = new Image();
  userImg.src = 'char.png';
  let userImgLoaded = false;
  userImg.onload = () => { userImgLoaded = true; };
  userImg.onerror = () => { userImgLoaded = false; };

  const fallback = document.createElement('canvas');
  fallback.width = 64; fallback.height = 64;
  const fctx = fallback.getContext('2d');
  fctx.fillStyle = '#FFDD57'; fctx.fillRect(0,0,64,64); fctx.fillStyle='#222'; fctx.fillRect(40,10,10,10);

  const bird = { x:80, y:100, w:50, h:70, vy:0, gravity:0.45, jump:-8 };
  const pipeWidth = 70;
  let pipes = [], spawnTimer = 0, score = 0;
  let running = false, gameOver = false;

  function computeHitbox(){
    const scaleX = bird.w / imgWidth;
    const scaleY = bird.h / imgHeight;
    return {
      x: bird.x + imgBBox.left * scaleX,
      y: bird.y + imgBBox.top * scaleY,
      w: bird.w - (imgBBox.left + imgBBox.right) * scaleX,
      h: bird.h - (imgBBox.top + imgBBox.bottom) * scaleY
    };
  }

  function playJump() {
    ensureAudioContext();
    if (jumpBuffer) playBuffer(jumpBuffer, 0.95);
    else playAudioFallback('jump.mp3');
  }

  function playGameOver() {
    ensureAudioContext();
    if (gameoverBuffer) playBuffer(gameoverBuffer, 1);
    else playAudioFallback('gameover.mp3');
  }

  function startBgm(){ bgm.currentTime=0; bgm.play().catch(()=>{}); }
  function stopBgm(){ bgm.pause(); bgm.currentTime=0; }

  function flap(){
    if (gameOver) { restart(); return; }
    ensureAudioContext();
    if (!running) { running = true; msgEl.style.display='none'; startBgm(); }
    playJump();
    bird.vy = bird.jump;
  }

  window.addEventListener('pointerdown', flap);
  window.addEventListener('touchstart', flap, {passive:false});
  window.addEventListener('keydown', e => { if (e.code==='Space'||e.key===' ') { e.preventDefault(); flap(); } }, {passive:false});

  function spawnPipe(){
    const gap = Math.max(110, Math.round(bird.h*1.6));
    const minTop = 20;
    const maxTop = canvas.height-gap-80;
    const top = Math.floor(Math.random()*(maxTop-minTop+1))+minTop;
    pipes.push({ x: canvas.width+20, top, bottom: top+gap, passed:false });
  }

  function update(){
    if (!running || gameOver) return;
    bird.vy += bird.gravity;
    bird.y += bird.vy;

    spawnTimer++;
    if (spawnTimer > 90){ spawnPipe(); spawnTimer = 0; }

    for (let i=pipes.length-1;i>=0;i--){
      const p = pipes[i]; p.x -= 3;
      if (!p.passed && p.x+pipeWidth < bird.x){ p.passed=true; score++; }
      if (p.x < -pipeWidth) pipes.splice(i,1);
    }

    if (bird.y < -50 || bird.y+bird.h > canvas.height+50){ endGame(); return; }

    const hb = computeHitbox();
    for (const p of pipes){
      const hit = hb.x < p.x+pipeWidth && hb.x+hb.w > p.x && (hb.y < p.top || hb.y+hb.h > p.bottom);
      if (hit){ endGame(); return; }
    }
  }

  function draw(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#70c5ce'); g.addColorStop(1,'#4ec0ca');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#2e8b34';
    for (const p of pipes){
      ctx.fillRect(p.x,0,pipeWidth,p.top);
      ctx.fillRect(p.x,p.bottom,pipeWidth,canvas.height-p.bottom);
      ctx.fillStyle = '#1f6f28';
      ctx.fillRect(p.x-4,p.top-8,pipeWidth+8,8);
      ctx.fillRect(p.x-4,p.bottom,pipeWidth+8,8);
      ctx.fillStyle = '#2e8b34';
    }

    if (userImgLoaded) ctx.drawImage(userImg, bird.x, bird.y, bird.w, bird.h);
    else ctx.drawImage(fallback, bird.x, bird.y, bird.w, bird.h);

    ctx.fillStyle='white';
    ctx.font = `${Math.floor(canvas.width*0.065)}px Arial`;
    ctx.fillText('Score: '+score, 10, Math.floor(canvas.height*0.05));
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  function endGame(){
    gameOver = true; running = false;
    stopBgm();
    playGameOver();
    msgEl.style.display='block';
    msgEl.innerHTML = `GAME OVER<br>Score: ${score}<br>Tap / Click to restart`;
  }

  function restart(){
    bird.y = canvas.height/2 - bird.h/2;
    bird.vy = 0;
    pipes = []; spawnTimer = 0; score = 0;
    running = false; gameOver = false;
    msgEl.style.display='block';
    msgEl.innerHTML = 'Tap / Click / Space to start';
  }

  // responsive canvas
  function resizeCanvas(){
    canvas.width = window.innerWidth * 0.95;
    canvas.height = window.innerHeight * 0.95;
    bird.x = canvas.width*0.2;
    bird.w = canvas.width*0.18;
    bird.h = canvas.height*0.25;
    restart();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  bird.y = canvas.height/2 - bird.h/2;
  requestAnimationFrame(loop);

  // unlock audio on first gesture
  function unlockAudio(){
    ensureAudioContext();
    if(audioCtx) audioCtx.resume().catch(()=>{});
    window.removeEventListener('pointerdown', unlockAudio);
    window.removeEventListener('keydown', unlockAudio);
    window.removeEventListener('touchstart', unlockAudio);
  }
  window.addEventListener('pointerdown', unlockAudio, {once:true});
  window.addEventListener('keydown', unlockAudio, {once:true});
  window.addEventListener('touchstart', unlockAudio, {once:true});
})();
</script>
</body>
</html>
