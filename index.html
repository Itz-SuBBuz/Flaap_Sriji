<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy — robust audio (jump + gameover)</title>
<style>
  html,body{height:100%;margin:0;background:linear-gradient(#70c5ce,#4ec0ca);display:flex;align-items:center;justify-content:center;font-family:Arial}
  #wrap{position:relative}
  canvas{display:block;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  #msg{position:absolute;width:100%;text-align:center;top:46%;transform:translateY(-50%);color:#fff;font-size:22px;text-shadow:0 2px 6px rgba(0,0,0,.5);pointer-events:none}
  #hint{position:absolute;right:8px;top:8px;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:8px;font-weight:700}
</style>
</head>
<body>
  <div id="wrap">
    <div id="msg">Click / Tap / Space to start</div>
    
    <canvas id="game" width="400" height="600"></canvas>
  </div>

<script>
(() => {
  // -------- WebAudio + element audio setup --------
  let audioCtx = null;
  function ensureAudioContext() {
    if (!audioCtx) {
      const C = window.AudioContext || window.webkitAudioContext;
      if (C) {
        audioCtx = new C();
        audioCtx.resume().then(()=> console.log('AudioContext ready')).catch(e => console.warn('AudioContext resume failed', e));
      } else {
        console.warn('WebAudio API not supported');
      }
    }
  }

  // bgm as <audio> for easy looping
  const bgm = new Audio('bgm.mp3');
  bgm.loop = true;
  bgm.volume = 0.35;
  bgm.addEventListener('error', e => console.warn('bgm load error', e));

  // We'll decode jump and gameOver to AudioBuffer
  let jumpBuffer = null;
  let gameoverBuffer = null;

  async function loadAudioBuffer(url) {
    try {
      const res = await fetch(url, {cache: 'no-store'});
      if (!res.ok) throw new Error(`${url} fetch failed: ${res.status}`);
      const arrayBuffer = await res.arrayBuffer();
      ensureAudioContext();
      if (!audioCtx) throw new Error('AudioContext unavailable');
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      console.log(`${url} decoded`);
      return audioBuffer;
    } catch (err) {
      console.warn('Failed to load/decode', url, err);
      return null;
    }
  }

  // Start loading buffers now (async)
  loadAudioBuffer('jump.mp3').then(b => jumpBuffer = b);
  loadAudioBuffer('gameover.mp3').then(b => gameoverBuffer = b);

  function playBuffer(buffer, volume=1) {
    try {
      if (!audioCtx || !buffer) return false;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      src.connect(gain).connect(audioCtx.destination);
      src.start(0);
      return true;
    } catch (e) {
      console.warn('playBuffer error', e);
      return false;
    }
  }

  // Fallback plain Audio play (may be blocked on some mobile browsers)
  function playAudioFallback(url) {
    try {
      const a = new Audio(url);
      a.volume = 1;
      a.currentTime = 0;
      a.play().catch(e => console.warn('fallback audio play rejected', e));
    } catch (e) {
      console.warn('fallback audio error', e);
    }
  }

  // --------- DOM & Game (your code) ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('msg');

  const imgWidth = 810, imgHeight = 1080;
  const imgBBox = { left: 76, right: 88, top: 422, bottom: 39 };

  const userImg = new Image();
  userImg.src = 'char.png';
  let userImgLoaded = false;
  userImg.onload = () => { userImgLoaded = true; console.log('char.png loaded'); };
  userImg.onerror = (e) => { userImgLoaded = false; console.warn('char.png failed to load', e); };

  const fallback = document.createElement('canvas');
  fallback.width = 64; fallback.height = 64;
  const fctx = fallback.getContext('2d');
  fctx.fillStyle = '#FFDD57'; fctx.fillRect(0,0,64,64); fctx.fillStyle='#222'; fctx.fillRect(40,10,10,10);

  const bird = { x:80, y: canvas.height/2 - 75, w:150, h:200, vy:0, gravity:0.45, jump:-8 };
  const pipeWidth = 70;
  let pipes = [], spawnTimer = 0, score = 0;
  let running = false, gameOver = false;

  function computeHitbox(){
    const scaleX = bird.w / imgWidth;
    const scaleY = bird.h / imgHeight;
    return {
      x: bird.x + imgBBox.left * scaleX,
      y: bird.y + imgBBox.top * scaleY,
      w: bird.w - (imgBBox.left + imgBBox.right) * scaleX,
      h: bird.h - (imgBBox.top + imgBBox.bottom) * scaleY
    };
  }

  // Play jump sound (Buffer preferred, fallback to audio element)
  function playJump() {
    // ensure audio unlocked
    ensureAudioContext();
    if (jumpBuffer && audioCtx) {
      playBuffer(jumpBuffer, 0.95);
      return;
    }
    // fallback
    playAudioFallback('jump.mp3');
  }

  // Play game over sound
  function playGameOver() {
    ensureAudioContext();
    if (gameoverBuffer && audioCtx) {
      playBuffer(gameoverBuffer, 1);
      return;
    }
    playAudioFallback('gameover.mp3');
  }

  // Start/Stop bgm
  function startBgm(){
    try { bgm.currentTime = 0; bgm.play().catch(e => console.warn('bgm play rejected', e)); } catch(e){ console.warn(e); }
  }
  function stopBgm(){
    try { bgm.pause(); bgm.currentTime = 0; } catch(e){ console.warn(e); }
  }

  // Input
  function flap(){
    if (gameOver) { restart(); return; }
    // unlock
    ensureAudioContext();

    if (!running) { running = true; msgEl.style.display='none'; startBgm(); }
    // play jump sound (restarts each time)
    playJump();
    bird.vy = bird.jump;
  }

  window.addEventListener('pointerdown', flap);
  window.addEventListener('keydown', (e) => { if (e.code==='Space' || e.key===' ') { e.preventDefault(); flap(); } }, {passive:false});

  function spawnPipe(){
    const gap = Math.max(110, Math.round(bird.h * 1.6)); // slightly smaller gap
    const minTop = 20;
    const maxTop = canvas.height - gap - 80;
    const top = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
    pipes.push({ x: canvas.width + 20, top, bottom: top + gap, passed:false });
  }

  function update(){
    if (!running || gameOver) return;
    bird.vy += bird.gravity;
    bird.y += bird.vy;

    spawnTimer++;
    if (spawnTimer > 90){ spawnPipe(); spawnTimer = 0; }

    for (let i=pipes.length-1;i>=0;i--){
      const p = pipes[i]; p.x -= 3;
      if (!p.passed && p.x + pipeWidth < bird.x){ p.passed = true; score++; }
      if (p.x < -pipeWidth) pipes.splice(i,1);
    }

    if (bird.y < -50 || bird.y + bird.h > canvas.height + 50){ endGame(); return; }

    const hb = computeHitbox();
    for (const p of pipes){
      const hit = hb.x < p.x + pipeWidth && hb.x + hb.w > p.x && (hb.y < p.top || hb.y + hb.h > p.bottom);
      if (hit){ endGame(); return; }
    }
  }

  function draw(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#70c5ce'); g.addColorStop(1,'#4ec0ca');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#2e8b34';
    for (const p of pipes){
      ctx.fillRect(p.x,0,pipeWidth,p.top);
      ctx.fillRect(p.x,p.bottom,pipeWidth,canvas.height-p.bottom);
      ctx.fillStyle = '#1f6f28';
      ctx.fillRect(p.x-4,p.top-8,pipeWidth+8,8);
      ctx.fillRect(p.x-4,p.bottom,pipeWidth+8,8);
      ctx.fillStyle = '#2e8b34';
    }

    if (userImgLoaded) ctx.drawImage(userImg, bird.x, bird.y, bird.w, bird.h);
    else ctx.drawImage(fallback, bird.x, bird.y, bird.w, bird.h);

    ctx.fillStyle='white'; ctx.font='26px Arial';
    ctx.fillText('Score: '+score, 10, 30);
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  function endGame(){
    gameOver = true; running = false;
    stopBgm();
    // play game-over sound
    playGameOver();
    msgEl.style.display='block';
    msgEl.innerHTML = `GAME OVER<br>Score: ${score}<br>Click / Tap to restart`;
  }

  function restart(){
    bird.y = canvas.height/2 - bird.h/2;
    bird.vy = 0;
    pipes = []; spawnTimer = 0; score = 0;
    running = false; gameOver = false;
    msgEl.style.display='block';
    msgEl.innerHTML = 'Click / Tap / Space to start';
  }

  // init
  bird.y = canvas.height/2 - bird.h/2;
  requestAnimationFrame(loop);

  // Unlock audio on first gesture to maximize compatibility
  function unlockAudio() {
    ensureAudioContext();
    // warm up by attempting quick plays (silently)
    if (audioCtx) {
      // nothing heavy; just resume ensures WebAudio unlocked
      audioCtx.resume().catch(()=>{});
    }
    // remove listeners
    window.removeEventListener('pointerdown', unlockAudio);
    window.removeEventListener('keydown', unlockAudio);
  }
  window.addEventListener('pointerdown', unlockAudio, {once:true});
  window.addEventListener('keydown', unlockAudio, {once:true});

  console.log('Game ready. If audio doesn\'t play: check that char.png, bgm.mp3, jump.mp3, gameover.mp3 are in same folder.');
  console.log('Open DevTools → Console and paste any red error messages here.');

  // expose console helpers
  window.__flappy = {
    setBirdSize: (w,h) => { bird.w=w; bird.h=h; restart(); },
    restart
  };
})();
</script>
</body>
</html>
